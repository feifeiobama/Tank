最后生成蓝方胜率

Model Version 1

single_threat i, j = 1 / dist_to_enemy_tank + w1 / dist_to_fire_enemy_tank // 追击 (+)
single_counter i, j = 1 / dist_to_fire_enemy_tank + w2 / dist_to_enemy_tank + fire_or_self卡路线?w3 // counter (+)

// dist_to_enemy_tank 0->2

single_tank_invade = (1 / dist_to_shoot_base ^ 2 + w4 * area_fire + w5 * single_threat) ^ w7  (+)
single_tank_alive = ((8 - area_move) * area_move + w8) / (single_threat + w6) (+)

single_tank_attack = single_tank_invade * single_tank_alive (+)
single_tank_defend = enemy_single_tank_invade * single_counter (+)
double_tank_buff = sqrt(single_tank_invade * single_tank_invade) / dist_between_my_tank (+)

side = sqrt(single_tank_attack ^ 2, w9 * single_tank_defend ^ 2)[2] + w10 * double_tank_buff
win_rate = blue / (blue - red)  (0,1)

Model Version 2

只以进攻思考问题，对方防御算在减弱进攻的范围内

* 是否采取风险突进：对方能否承担自己不突进造成的后果 ?
* 重叠以后的情况？
* 到达底线以后的情况?

tank_attack = g(dist_to_fire_base, being_blocked, being_chased)
both_attack_enemy_tank = f(dist_to_fire_tank1, dist_to_fire_tank2)
cooperate_attack = sum(both_attack_enemy_tank)
side_attack = w1 * sum(tank_attack) + w2 * cooperate_attack
final_score = sigmoid(blue_attack - red_attack)

TODO:
一边僵局另一边放手；对峙时卡人，越过己方后追及；没有进攻性